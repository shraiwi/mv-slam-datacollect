<!DOCTYPE html>
<head>
    <style>
        html {
            background-color: black;
            color: white !important;
        }
        html, body {
            margin: 0;
            overflow: visible;
            overflow-x: hidden;

            position: relative;

            font-weight: bold;
        }

        @keyframes fadeborders {
            from { outline-color: rgba(255, 0, 0, 0); }
            50%  { outline-color: rgba(255, 0, 0, 1); }
            to   { outline-color: rgba(255, 0, 0, 0);  }
        }

        video {
            display: block;
            margin: auto;
            width: 100vw;
            height: 100vh;
        }

        .recording {
            outline: 5px solid currentColor;
            outline-offset: -5px;
            animation-name: fadeborders;
            animation-duration: 2s;
            animation-iteration-count: infinite;
        }

        .recording * {
            position: relative;
            z-index: -1;
        }

        #graphoverlay {
            position: absolute;
            top: 10px;
            left: 10px;
        }

        canvas {
            background-color: rgba(0, 0, 0, 0.5);
        }

        button {
            font-size: 2em;
            color: white;
            border: none;
            filter: brightness(100%);
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.5);
        }

        button#startstop {
            width: 100vw;
            height: 100px;
            position: fixed;
            display: inline-block;
            bottom: 0;
        }

        button:active {
            background-color: rgba(255, 255, 255, 0.5);
        }

        button:hover {
            background-color: rgba(128, 128, 128, 0.5);
            filter: brightness(110%);
        }

        button:disabled {
            filter: brightness(50%);
        }

        button:disabled h1 {
            background-color: rgba(128, 128, 128, 0.5);
        }

        button h1 {
            font-size: 1.5em;
            margin: auto;
        }
    </style>

</head>
<body onclick="$toggleFullscreen()">
    <video autoplay></video>
    <button id="startstop" disabled><h1>record</h1></button>
    <div id="graphoverlay">
        <canvas id="accel" width="200" height="90"></canvas>
        <canvas id="gyro" width="200" height="90"></canvas>
        <br>
        <button id="video-dl"><h1>download video</h1></button>
        <button id="data-dl"><h1>download data</h1></button>
    </div>
    <script>

        const $id = (s) => document.getElementById(s);
        const $query = (s) => document.querySelector(s);
        const $delayms = (ms) => new Promise((res) => setTimeout(res, ms));
        const $once = (obj, func) => new Promise((res) => obj.addEventListener(func, res))
        const $downloadVideo = (blob, name) => {
            const a = document.createElement("a");
            const re = /\/(.*);?/;
            document.body.appendChild(a);

            a.href = URL.createObjectURL(blob);
            a.download = `${name}.${re.exec(blob.type)[1]}`;
            a.click();

            document.body.removeChild(a);

            URL.revokeObjectURL(a.href);
        };
        const $timeAsFile = () => {
            let now = new Date();

            const [yr, mo, dy, hr, mi, sc] = [
                now.getFullYear(),
                now.getMonth() + 1,
                now.getDate(),
                now.getHours(),
                now.getMinutes(),
                now.getSeconds(),
            ];

            return [mo, dy, yr, hr, mi, sc].join('-');
        }
        const $toggleFullscreen = () => {
            document.body.requestFullscreen();
        }

        var _dummy = null;

        const COLORS = {
            CLEAR: "rgba(0, 0, 0, 0)",
            RED: "red",
            GREEN: "green",
            BLUE: "blue",
            WHITE: "white",
            BLACK: "black",
        };

        class Graph {

            constructor(elem, axes, clearColor = COLORS.CLEAR) {
                this.elem = elem;
                this.axes = axes;
                /*
                x: {
                    color: "red",
                    scale: 10,
                }

                */
                this.ctx = elem.getContext("2d");
                this.dims = [ elem.width, elem.height ];
                this.clearColor = clearColor;
            }

            fillText(x, y, text, color = COLORS.BLACK, size = 12, font = "Arial") {
                this.ctx.save();

                this.ctx.lineStyle = COLORS.CLEAR;
                this.ctx.fillStyle = color;

                this.ctx.font = `${size}px ${font}`;
                this.ctx.textBaseline = "top";

                this.ctx.fillText(text, x, y)

                this.ctx.restore();
            }

            putData(...data) {
                this.ctx.save();

                this.clear();

                this.ctx.lineWidth = 1;

                let i = 0;
                const entries = Object.entries(this.axes);
                for (const [axisName, axisProp] of entries) {

                    if (!axisProp._history) axisProp._history = [];
                    
                    const offset = ((i + 1) / (entries.length + 1)) * this.dims[1];
                    const y = (-data[i] * axisProp.scale + offset);

                    axisProp._history.push(y);
                    if (axisProp.length > this.dims[0]) axisProp._history.shift();

                    this.ctx.strokeStyle = axisProp.color;

                    this.ctx.beginPath();

                    for (let x = 0; x < axisProp._history.length; x++) {
                        this.ctx[x ? "lineTo" : "moveTo"](x, axisProp._history[x])
                    }
                    
                    this.ctx.stroke();

                    i++;
                }

                this.ctx.restore();
            }

            fillWith(color = COLORS.CLEAR) {
                this.ctx.save();

                this.ctx.lineStyle = COLORS.CLEAR;
                this.ctx.fillStyle = color;
                this.ctx.fillRect(0, 0, ...this.dims);

                this.ctx.restore();
            }

            clear() {
                this.ctx.clearRect(0, 0, ...this.dims);
            }

            move(x, y, overflow = COLORS.CLEAR) {
                this.ctx.save();

                const dat = this.ctx.getImageData(0, 0, ...this.dims);

                this.clear();

                this.ctx.putImageData(dat, x, y);

                this.ctx.restore();
            }
        }

        class Recorder {
            constructor(videoParams = {}, sensorParams = {}) {
                videoParams = {
                    ...{
                        constraints: {},
                        container: "video/mp4",
                        //codec: "h264",
                        bitrate: 1000000,
                    }, 
                    ...videoParams
                };

                sensorParams = {
                    ...{
                        /*
                        accelerometer: {
                            frequency: 100,
                        },
                        gyroscope: {...},
                        magnetometer: {...},
                        */
                    },
                    ...sensorParams
                };

                this.mediaRecorder = null;

                this.videoParams = videoParams;
                this.videoChunks = null;

                this.videoParams.mimeType = this.videoParams.container
                    + (this.videoParams.codec ? `;codecs=${this.videoParams.codec}` : "");

                this.sensorParams = sensorParams;
                this.sensorChunks = null;
                this.sensors = null;

                this.state = "inactive";

                if (!MediaRecorder.isTypeSupported(this.videoParams.mimeType)) {
                    console.warn("MIME type not supported!");
                }
            }

            _onVideoData(chunk) {
                console.log("chunk recieved!");
                this.videoChunks.push(chunk.data);
            }

            async init() {
                
                // init video

                this.videoChunks = [];

                let stream = await navigator.mediaDevices.getUserMedia({
                    video: this.videoParams.constraints || {},
                });

                if (this.videoParams.videoElem) this.videoParams.videoElem.srcObject = stream;

                this.mediaRecorder = new MediaRecorder(stream, {
                    mimeType: this.videoParams.mimeType,
                    videoBitsPerSecond: this.videoParams.bitrate,
                });

                this.mediaRecorder.ondataavailable = (c) => this._onVideoData(c);

                // init sensors (if available)

                this.sensors = {};

                const SENSOR_MAPPING = {
                    ...("Accelerometer" in window && { accelerometer: Accelerometer }),
                    ...("Gyroscope" in window && { gyroscope: Gyroscope }),
                    ...("Magnetometer" in window && { magnetometer: Magnetometer }),
                }

                for (let key in this.sensorParams) {
                    if (!(key in SENSOR_MAPPING)) console.warn(`Sensor '${key}' not supported!`);

                    this.sensors[key] = {
                        obj: new SENSOR_MAPPING[key](this.sensorParams[key]),
                        data: [],
                    }

                    this.sensors[key].obj.onreading = () => {
                        const data = [
                            this.sensors[key].obj.x,
                            this.sensors[key].obj.y,
                            this.sensors[key].obj.z,
                        ];
                        if (this.sensorParams[key].callback) {
                            this.sensorParams[key].callback(...data);
                        }
                        this.sensors[key].data.push(data);
                    };
                }
            }

            start() {

                this.mediaRecorder.start();

                for (const sensor of Object.values(this.sensors)) {
                    sensor.obj.start();
                }

                document.body.classList.add("recording");

                this.state = "active";

                console.log("recording started");
            }

            async stop() {

                const promises = [];

                promises.push($once(this.mediaRecorder, "stop"));

                this.mediaRecorder.stop()

                for (const sensor of Object.values(this.sensors)) {
                    sensor.obj.stop();
                }

                await Promise.all(promises);

                document.body.classList.remove("recording");

                this.state = "inactive";

                console.log("recording stopped");
            }

            getVideoBlob() {
                return new Blob(this.videoChunks, {
                    type: this.videoParams.mimeType,
                });
            }

            getSensorBlob() {

            }
        }

        const ACCEL_GRAPH = new Graph($id("accel"), {
            x: { color: "red", scale: 5 },
            y: { color: "green", scale: 5 },
            z: { color: "blue", scale: 5 },
        });

        const GYRO_GRAPH = new Graph($id("gyro"), {
            x: { color: "red", scale: 10 },
            y: { color: "green", scale: 10 },
            z: { color: "blue", scale: 10 },
        });

        const RECORDER = new Recorder({
            videoElem: $query("video"),

            constraints: {
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                frameRate: { min: 30, ideal: 60 },
                facingMode: { ideal: "environment" },
            },

            container: "video/webm",
            codec: "vp8",
            bitrate: 10000000,
        }, {
            accelerometer: {
                callback: (...data) => ACCEL_GRAPH.putData(...data),
                frequency: 60,
            },
            gyroscope: {
                callback: (...data) => GYRO_GRAPH.putData(...data),
                frequency: 60,
            },
        });

        const RECBUTTON = $id("startstop");

        RECBUTTON.setState = (html, color = "rgba(255, 255, 255, 0.5)") => {
            RECBUTTON.children[0].innerHTML = html;
            RECBUTTON.style.backgroundColor = color;
        }

        var blob = null;

        RECBUTTON.onclick = async () => {
            switch (RECORDER.state) {
                case "inactive":
                    RECORDER.start();
                    RECBUTTON.setState("stop recording");
                    break;
                case "active": 
                    await RECORDER.stop();
                    RECBUTTON.setState("record");
                    break;
            }
        }

        RECORDER.init().then(async () => {
            RECBUTTON.disabled = false;
            /*RECORDER.start();
            await $delayms(5000);
            await RECORDER.stop();

            blob = RECORDER.getVideoBlob();

            $downloadVideo(blob, $timeAsFile());

            console.log(blob);*/
        });

        /*for (let i = 0; i < 100; i++) {
            ACCEL_GRAPH.putData(Math.sin(i * 0.1), i, i%10);
        }*/
    </script>
</body>